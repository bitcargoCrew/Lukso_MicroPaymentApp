"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllInBatches = exports.mapEnglishAuction = exports.mapDirectListing = void 0;
const contract_js_1 = require("../../contract/contract.js");
const units_js_1 = require("../../utils/units.js");
const getCurrencyMetadata_js_1 = require("../erc20/read/getCurrencyMetadata.js");
const isERC721_js_1 = require("../erc721/read/isERC721.js");
const isERC1155_js_1 = require("../erc1155/read/isERC1155.js");
/**
 * Retrieves the NFT asset based on the provided options.
 * @param options The transaction options.
 * @returns A promise that resolves to the NFT asset.
 * @example
 * ```ts
 * import { getNFTAsset } from "thirdweb/extensions/marketplace";
 *
 * const nft = await getNFTAsset({ contract, tokenId: 1n });
 * ```
 */
async function getNFTAsset(options) {
    const [erc721, erc1155] = await Promise.all([
        (0, isERC721_js_1.isERC721)(options),
        (0, isERC1155_js_1.isERC1155)(options),
    ]);
    switch (true) {
        case erc721: {
            const { getNFT } = await Promise.resolve().then(() => require("../erc721/read/getNFT.js"));
            return getNFT(options);
        }
        case erc1155: {
            const { getNFT } = await Promise.resolve().then(() => require("../erc1155/read/getNFT.js"));
            return getNFT(options);
        }
        default: {
            throw new Error("Contract is neither ERC721 nor ERC1155.");
        }
    }
}
function computeStatus(options) {
    switch (options.listingStatus) {
        case 1: {
            if (options.startTimestamp > options.blockTimeStamp) {
                return "CREATED";
            }
            if (options.endTimestamp < options.blockTimeStamp) {
                return "EXPIRED";
            }
            return "ACTIVE";
        }
        case 2: {
            return "COMPLETED";
        }
        case 3: {
            return "CANCELLED";
        }
        default: {
            throw new Error(`Invalid listing status: "${options.listingStatus}"`);
        }
    }
}
/**
 * @internal
 */
async function mapDirectListing(options) {
    const { latestBlock, rawListing } = options;
    // process the listing
    const status = computeStatus({
        listingStatus: rawListing.status,
        blockTimeStamp: latestBlock.timestamp,
        startTimestamp: rawListing.startTimestamp,
        endTimestamp: rawListing.endTimestamp,
    });
    const [currencyValuePerToken, nftAsset] = await Promise.all([
        (0, getCurrencyMetadata_js_1.getCurrencyMetadata)({
            contract: (0, contract_js_1.getContract)({
                ...options.contract,
                address: rawListing.currency,
            }),
        }),
        getNFTAsset({
            ...options,
            contract: (0, contract_js_1.getContract)({
                ...options.contract,
                address: rawListing.assetContract,
            }),
            tokenId: rawListing.tokenId,
        }),
    ]);
    return {
        id: rawListing.listingId,
        creatorAddress: rawListing.listingCreator,
        assetContractAddress: rawListing.assetContract,
        tokenId: rawListing.tokenId,
        quantity: rawListing.quantity,
        currencyContractAddress: rawListing.currency,
        currencyValuePerToken: {
            ...currencyValuePerToken,
            value: rawListing.pricePerToken,
            displayValue: (0, units_js_1.toTokens)(rawListing.pricePerToken, currencyValuePerToken.decimals),
        },
        pricePerToken: rawListing.pricePerToken,
        asset: nftAsset,
        startTimeInSeconds: rawListing.startTimestamp,
        endTimeInSeconds: rawListing.endTimestamp,
        isReservedListing: rawListing.reserved,
        status,
    };
}
exports.mapDirectListing = mapDirectListing;
/**
 * @internal
 */
async function mapEnglishAuction(options) {
    const { latestBlock, rawAuction } = options;
    // process the listing
    const status = computeStatus({
        listingStatus: rawAuction.status,
        blockTimeStamp: latestBlock.timestamp,
        startTimestamp: rawAuction.startTimestamp,
        endTimestamp: rawAuction.endTimestamp,
    });
    const [auctionCurrencyMetadata, nftAsset] = await Promise.all([
        (0, getCurrencyMetadata_js_1.getCurrencyMetadata)({
            contract: (0, contract_js_1.getContract)({
                ...options.contract,
                address: rawAuction.currency,
            }),
        }),
        getNFTAsset({
            ...options,
            contract: (0, contract_js_1.getContract)({
                ...options.contract,
                address: rawAuction.assetContract,
            }),
            tokenId: rawAuction.tokenId,
        }),
    ]);
    return {
        id: rawAuction.auctionId,
        creatorAddress: rawAuction.auctionCreator,
        assetContractAddress: rawAuction.assetContract,
        tokenId: rawAuction.tokenId,
        quantity: rawAuction.quantity,
        currencyContractAddress: rawAuction.currency,
        asset: nftAsset,
        startTimeInSeconds: rawAuction.startTimestamp,
        endTimeInSeconds: rawAuction.endTimestamp,
        status,
        minimumBidAmount: rawAuction.minimumBidAmount,
        minimumBidCurrencyValue: {
            ...auctionCurrencyMetadata,
            value: rawAuction.minimumBidAmount,
            displayValue: (0, units_js_1.toTokens)(rawAuction.minimumBidAmount, auctionCurrencyMetadata.decimals),
        },
        buyoutBidAmount: rawAuction.buyoutBidAmount,
        buyoutCurrencyValue: {
            ...auctionCurrencyMetadata,
            value: rawAuction.buyoutBidAmount,
            displayValue: (0, units_js_1.toTokens)(rawAuction.buyoutBidAmount, auctionCurrencyMetadata.decimals),
        },
        timeBufferInSeconds: rawAuction.timeBufferInSeconds,
        bidBufferBps: rawAuction.bidBufferBps,
    };
}
exports.mapEnglishAuction = mapEnglishAuction;
/**
 * @internal
 */
async function getAllInBatches(fn, options) {
    let start = options.start;
    const batches = [];
    while (options.end - start > options.maxSize) {
        batches.push(fn(start, options.end + options.maxSize - 1n));
        start += options.maxSize;
    }
    batches.push(fn(start, options.end - 1n));
    return await Promise.all(batches);
}
exports.getAllInBatches = getAllInBatches;
//# sourceMappingURL=utils.js.map